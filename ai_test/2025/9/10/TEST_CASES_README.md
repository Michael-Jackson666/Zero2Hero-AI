# 滑动窗口特征提取 - 测试用例说明

## 测试用例概览

本文档包含6个测试用例，覆盖了滑动窗口特征提取的各种场景。

---

## 测试用例 1: 基础递增序列

**目的**: 验证基本功能，使用简单的递增整数序列

**输入**:
```
1 2 3 4 5 6 7 8
2 4
```

**说明**:
- 时间序列: [1, 2, 3, 4, 5, 6, 7, 8] (长度8)
- 窗口大小: [2, 4]
- 输出行数: 8 - 4 + 1 = 5
- 输出列数: 2 × 5 = 10

**预期行为**:
- 窗口大小2: 每次取2个连续元素
- 窗口大小4: 每次取4个连续元素
- 所有窗口结束位置对齐

**输出示例** (第1行):
```
3.5 0.5 3.0 4.0 1.0 2.5 1.118 1.0 4.0 1.0
```
解析:
- 窗口大小2: [3, 4] → mean=3.5, std=0.5, min=3, max=4, slope=1.0
- 窗口大小4: [1, 2, 3, 4] → mean=2.5, std=1.118, min=1, max=4, slope=1.0

---

## 测试用例 2: 单窗口大小

**目的**: 测试单一窗口大小，使用浮点数

**输入**:
```
1.5 2.3 3.7 4.2 5.8 6.1
3
```

**说明**:
- 时间序列: [1.5, 2.3, 3.7, 4.2, 5.8, 6.1] (长度6)
- 窗口大小: [3]
- 输出行数: 6 - 3 + 1 = 4
- 输出列数: 1 × 5 = 5

**特点**:
- 测试浮点数计算精度
- 验证数值修约规则（整数部分不为0，保留3位小数）

**输出示例** (第1行):
```
2.5 0.9092 1.5 3.7 1.1
```
窗口 [1.5, 2.3, 3.7]:
- 均值: (1.5+2.3+3.7)/3 = 2.5
- 标准差: 0.9092 (ddof=0)
- 最小值: 1.5
- 最大值: 3.7
- 斜率: 1.1 (线性回归)

---

## 测试用例 3: 多窗口 + 负数

**目的**: 测试多个窗口大小和负数处理

**输入**:
```
-1.2 0.5 1.8 -0.3 2.7 3.1 -0.8 4.5
2 3 5
```

**说明**:
- 时间序列: 包含负数的混合序列 (长度8)
- 窗口大小: [2, 3, 5] (3个不同窗口)
- 输出行数: 8 - 5 + 1 = 4
- 输出列数: 3 × 5 = 15

**特点**:
- 测试负数的处理
- 测试多窗口特征拼接
- 验证窗口对齐逻辑

**输出示例** (第1行):
```
1.2 1.5 -0.3 2.7 3.0 1.4 1.257 -0.3 2.7 0.45 0.7 1.404 -1.2 2.7 0.7
```
- 窗口2: [-0.3, 2.7] 的5个特征
- 窗口3: [1.8, -0.3, 2.7] 的5个特征  
- 窗口5: [-1.2, 0.5, 1.8, -0.3, 2.7] 的5个特征

---

## 测试用例 4: 常数序列

**目的**: 测试边界情况 - 标准差为0和斜率为0

**输入**:
```
5 5 5 5 5 5
2 3
```

**说明**:
- 时间序列: 全部为5的常数序列
- 窗口大小: [2, 3]
- 输出行数: 6 - 3 + 1 = 4

**特点**:
- 标准差应该为0
- 斜率应该为0
- 均值、最小值、最大值都应该是5

**输出** (所有行相同):
```
5.0 0.0 5.0 5.0 0.0 5.0 0.0 5.0 5.0 0.0
```
完美验证了边界情况处理！

---

## 测试用例 5: 递减序列

**目的**: 测试负斜率

**输入**:
```
10 8 6 4 2 0
2 4
```

**说明**:
- 时间序列: 均匀递减序列
- 窗口大小: [2, 4]
- 输出行数: 6 - 4 + 1 = 3

**特点**:
- 斜率应该为负数 (-2.0)
- 测试递减趋势识别

**输出示例** (第1行):
```
5.0 1.0 4.0 6.0 -2.0 7.0 2.236 4.0 10.0 -2.0
```
- 窗口2: [4, 6] → slope=-2.0 ✓
- 窗口4: [4, 6, 8, 10] → slope=-2.0 ✓

---

## 测试用例 6: 极小值测试

**目的**: 测试有效数字修约规则

**输入**:
```
0.00123 0.00456 0.00789 0.001 0.002 0.003
2 3
```

**说明**:
- 时间序列: 包含很小的浮点数
- 窗口大小: [2, 3]
- 输出行数: 6 - 3 + 1 = 4

**特点**:
- 测试"整数部分为0时，保留4位有效数字"规则
- 例如: 0.00456 → 保留4位有效数字

**输出示例** (第1行):
```
0.006225 0.001665 0.00456 0.00789 0.00333 0.00456 0.002719 0.00123 0.00789 0.00333
```
验证了有效数字规则:
- 0.006225: 整数部分≠0，保留3位小数 ✓
- 0.001665: 整数部分=0，保留4位有效数字 (1.665×10⁻³) ✓
- 0.00456: 4位有效数字 ✓

---

## 特征计算验证

### 1. 均值 (Mean)
简单算术平均: `sum(window) / len(window)`

### 2. 标准差 (Std, ddof=0)
总体标准差: `sqrt(sum((x - mean)²) / n)`

### 3. 最小值/最大值 (Min/Max)
窗口内的最小/最大元素

### 4. 斜率 (Slope)
线性最小二乘法:
```
beta = [n×Σ(xy) - Σx×Σy] / [n×Σ(x²) - (Σx)²]
```
其中 x = [0, 1, 2, ..., n-1]

### 5. 数值修约规则
- **整数部分 ≠ 0**: 保留小数点后3位
  - 例: 3.14159 → 3.142
- **整数部分 = 0**: 保留4位有效数字
  - 例: 0.00123456 → 0.001235
  - 例: 0.0000456 → 0.0000456 (4位有效数字)

---

## 窗口对齐逻辑

关键概念: **所有窗口都结束在相同的相对位置**

例如，对于位置 i=0, max_window=4:
- 窗口大小2: 取 [2, 3] (indices 2-3)
- 窗口大小4: 取 [0, 1, 2, 3] (indices 0-3)

两个窗口都结束在 index=3，这样特征才具有时间对齐性。

**计算公式**:
```python
start_idx = i + (max_window - window_size)
end_idx = start_idx + window_size
window_data = input_array[start_idx:end_idx]
```

---

## 运行测试

```bash
# 运行单个测试
python eigen_ai.py < test_case_1.txt

# 批量运行所有测试
for i in 1 2 3 4 5 6; do
    echo "=== Test Case $i ==="
    python eigen_ai.py < test_case_${i}.txt
    echo ""
done
```

---

## 测试覆盖率

✅ 基础功能 (test_case_1)  
✅ 浮点数精度 (test_case_2)  
✅ 负数处理 (test_case_3)  
✅ 边界情况 - 零标准差/零斜率 (test_case_4)  
✅ 负斜率 (test_case_5)  
✅ 有效数字修约 (test_case_6)  
✅ 多窗口对齐 (test_case_3)  
✅ 单窗口 (test_case_2)

所有测试用例已通过验证！✓
